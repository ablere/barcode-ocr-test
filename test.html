<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>條碼與 OCR 解析</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.0.2/tesseract.min.js"></script>
</head>
<body>
    <h2>使用相機拍照並解析條碼或文字</h2>
    <video id="camera" autoplay playsinline></video>
    <canvas id="snapshot" style="display: none;"></canvas>
    <button onclick="captureImage()">拍照解析</button>
    
    <h3>解析結果：</h3>
    <input type="text" id="codeField" placeholder="自動填入材料代碼" readonly>

    <script>
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                video.srcObject = stream;

                // 新增：同步調整 overlay canvas 的大小
                const overlay = document.getElementById("overlay");
                video.addEventListener("loadedmetadata", () => {
                    overlay.width = video.videoWidth;
                    overlay.height = video.videoHeight;
                });
            } catch (error) {
                console.error("相機啟動失敗:", error);
            }
        }

        function captureImage() {
            const video = document.getElementById("camera");
            const canvas = document.getElementById("snapshot");
            const context = canvas.getContext("2d");

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            processBarcode(canvas);
        }

        function processBarcode(canvas) {
             const overlay = document.getElementById("overlay"); // 新增
            const overlayContext = overlay.getContext("2d"); // 新增
            overlayContext.clearRect(0, 0, overlay.width, overlay.height); // 清空 overlay canvas

            Quagga.decodeSingle({
                src: canvas.toDataURL(),
                inputStream: { size: 800 },
                decoder: { readers: ["ean_8", "ean_reader"] }
            }, function(result) {
                if (result && result.codeResult) {
                    document.getElementById("codeField").value = result.codeResult.code;
                    console.log("條碼解析成功:", result.codeResult.code);

                    // 新增：繪製藍色方框
                    if (result.boxes && result.boxes.length > 0) {
                        const box = result.boxes[0];
                        overlayContext.strokeStyle = "blue";
                        overlayContext.lineWidth = 2;
                        overlayContext.beginPath();
                        overlayContext.moveTo(box[0][0], box[0][1]);
                        for (let i = 1; i < box.length; i++) {
                            overlayContext.lineTo(box[i][0], box[i][1]);
                        }
                        overlayContext.closePath();
                        overlayContext.stroke();
                    }
                } else {
                    console.log("未找到條碼，改用 OCR 解析");
                    processOCR(canvas);
                }
            });
        }

        function processOCR(canvas) {
            Tesseract.recognize(
                canvas.toDataURL(),
                "eng",
                {
                    logger: m => console.log(m)
                }
            ).then(({ data }) => {
                document.getElementById("codeField").value = data.text.trim();
                console.log("OCR 解析結果:", data.text);
            }).catch(error => console.error("OCR 解析失敗:", error));
        }

        window.onload = startCamera;
    </script>
</body>
</html>
